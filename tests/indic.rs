mod common;
mod shape;

use std::path::Path;
use std::rc::Rc;

use allsorts::binary::read::ReadScope;
use allsorts::error::ShapingError;
use allsorts::gsub::{self, FeatureMask, Features, RawGlyph};
use allsorts::scripts::preprocess_text;
use allsorts::tables::cmap::CmapSubtable;
use allsorts::tables::{FontTableProvider, OpenTypeFont};
use allsorts::{tag, Font, DOTTED_CIRCLE};

// Variant of `bin/shape::shape_ttf`
fn shape_ttf_indic<'a, T: FontTableProvider>(
    font: &mut Font<T>,
    script_tag: u32,
    opt_lang_tag: Option<u32>,
    text: &str,
) -> Result<Vec<u16>, ShapingError> {
    let cmap_subtable_data = font.cmap_subtable_data().to_vec();
    let cmap_subtable = ReadScope::new(&cmap_subtable_data)
        .read::<CmapSubtable<'_>>()
        .expect("no suitable cmap subtable");

    let mut chars = text.chars().collect();
    preprocess_text(&mut chars, script_tag);

    let res_opt_glyphs: Result<Vec<_>, _> = chars
        .iter()
        .map(|ch| shape::map_glyph(&cmap_subtable, *ch))
        .collect();
    let mut opt_glyphs = res_opt_glyphs?;

    // Mimic the existing behaviour of Prince, which is to split a sequence if
    // a font is missing a character glyph. We previously copied the behaviour
    // in `shape.rs`, where the missing glyphs are merely omitted. This can be
    // misleading, especially when comparing the glyph indices as generated by
    // the corpus test against the PDF as generated by Prince.
    //
    // Example:
    //   Assumptions:
    //     1. A and B can form a ligature A+B iff D is base.
    //     2. A+B and C can form a ligature A+B+C iff D is base.
    //
    //   Test sequence: [A, B, Missing, C, D]
    //          Prince: [A, B] [Missing] [C, D] - No ligation. The sequence is split, and
    //                                            D is no longer the base of A and B
    //        shape.rs: [A+B+C, D] - Unexpected ligature; doesn't match Prince's PDF output
    let mut glyphs: Vec<Vec<RawGlyph<()>>> = Vec::new();
    while !opt_glyphs.is_empty() {
        let i = opt_glyphs
            .iter()
            .position(Option::is_none)
            .unwrap_or(opt_glyphs.len() - 1);

        let sub = opt_glyphs.drain(..=i).flatten().collect(); // `flatten` removes any end `None`s
        glyphs.push(sub);
    }

    let gsub_cache = font
        .gsub_cache()
        .expect("unable to get gsub cache")
        .expect("missing gsub table");
    let gdef_table = font.gdef_table().expect("unable to get gdef table");

    let dotted_circle_index = cmap_subtable.map_glyph(DOTTED_CIRCLE as u32)?.unwrap_or(0);
    for gs in glyphs.iter_mut() {
        gsub::apply(
            dotted_circle_index,
            &gsub_cache,
            gdef_table.as_ref().map(Rc::as_ref),
            script_tag,
            opt_lang_tag,
            &Features::Mask(FeatureMask::default()),
            None,
            font.num_glyphs(),
            gs,
        )?;
    }

    let glyph_indices = glyphs
        .into_iter()
        .flatten()
        .map(|g| g.glyph_index)
        .collect();

    Ok(glyph_indices)
}

fn run_test<P: AsRef<Path>>(
    test_data: &TestData,
    expected_outputs_path: P,
    font_path: P,
    ignore: &[u16],
    expected_num_fail: usize,
) {
    let inputs = common::read_inputs("tests/indic", test_data.inputs_path);
    let expected_outputs =
        common::parse_expected_outputs("tests/indic", expected_outputs_path, ignore);
    assert_eq!(expected_outputs.len(), inputs.len());

    let font_buffer = common::read_fixture_font(font_path);
    let opentype_file = ReadScope::new(&font_buffer)
        .read::<OpenTypeFont<'_>>()
        .unwrap();
    let font_table_provider = opentype_file
        .table_provider(0)
        .expect("error reading font file");
    let mut font = Font::new(Box::new(font_table_provider)).expect("error reading font data");

    let script_tag = tag::from_string(test_data.script_tag).expect("invalid script tag");
    let opt_lang_tag = Some(tag::from_string(test_data.lang_tag).expect("invalid language tag"));

    let mut num_pass = 0;
    let mut num_fail = 0;
    for (i, input) in inputs.iter().enumerate() {
        let actual_output = shape_ttf_indic(&mut font, script_tag, opt_lang_tag, input);

        match (&actual_output, &expected_outputs[i]) {
            (Ok(actual_output), (expected_output, reason)) if actual_output == expected_output => {
                // If a successful test has a (failure) reason attached,
                // we may want to know about it
                if let Some(reason) = reason {
                    println!("[SUCCESS]");
                    println!("line {:0>5}: {}", i + 1, input);
                    println!("    reason: {}", reason);
                    println!();
                }

                num_pass += 1;
            }
            (result, (expected_output, reason)) => {
                println!("line {:0>5}: {}", i + 1, input);
                println!("  expected: {:?}", expected_output);
                match result {
                    Ok(actual_output) => println!("    actual: {:?}", actual_output),
                    Err(error) => println!("    actual: {:?}", error),
                };
                if let Some(reason) = reason {
                    println!("    reason: {}", reason);
                }
                println!();

                num_fail += 1;
            }
        }
    }

    println!("total: {:?}", inputs.len());
    println!(" pass: {:?}", num_pass);
    println!(" fail: {:?}", num_fail);

    assert_eq!(num_pass + num_fail, inputs.len());
    assert_eq!(num_fail, expected_num_fail);
}

fn run_test_bad<P: AsRef<Path>>(test_data: &TestData, font_path: P) {
    let inputs = common::read_inputs("tests/indic", test_data.inputs_path);

    let font_buffer = common::read_fixture_font(font_path);
    let opentype_file = ReadScope::new(&font_buffer)
        .read::<OpenTypeFont<'_>>()
        .unwrap();
    let font_table_provider = opentype_file
        .table_provider(0)
        .expect("error reading font file");
    let mut font = Font::new(Box::new(font_table_provider)).expect("error reading font data");
    let script_tag = tag::from_string(test_data.script_tag).expect("invalid script tag");
    let opt_lang_tag = Some(tag::from_string(test_data.lang_tag).expect("invalid language tag"));

    for input in inputs.iter() {
        let _actual_output = shape_ttf_indic(&mut font, script_tag, opt_lang_tag, input);
    }
}

struct TestData<'a> {
    inputs_path: &'a str,
    script_tag: &'a str,
    lang_tag: &'a str,
}

// Run with `-- --nocapture` to view details of failed test cases
#[cfg(test)]
mod harfbuzz {
    use super::*;

    // HarfBuzz replaces joiner glyphs with the space glyph, which we
    // omit from the output comparisons as our (current) approach is
    // different (we strip all joiners from the glyph buffer after GSUB)
    const JOINER_GLYPH_INDEX: u16 = 3;

    mod devanagari {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.hi",
            script_tag: "deva",
            lang_tag: "HIN",
        };

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.hi",
                    "devanagari/lohit_hi.ttf",
                    &[JOINER_GLYPH_INDEX],
                    34,
                );
            }

            #[test]
            #[cfg(feature = "prince")]
            fn test_mangal() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-mangal.hi",
                    "devanagari/mangal.ttf",
                    &[JOINER_GLYPH_INDEX],
                    89,
                );
            }

            #[test]
            fn test_sahadeva() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-sahadeva.hi",
                    "devanagari/sahadeva.ttf",
                    &[JOINER_GLYPH_INDEX],
                    90,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_annapurna() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-annapurna.hi",
                    "devanagari/AnnapurnaSIL-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    4,
                );
            }

            #[test]
            #[cfg(feature = "prince")]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.hi",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    34,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.hi",
                    "noto/NotoSansDevanagari-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    7,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.hi",
                    "noto/NotoSerifDevanagari-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    27,
                );
            }
        }
    }

    mod bengali {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.bn",
            script_tag: "beng",
            lang_tag: "BEN",
        };

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.bn",
                    "bengali/Lohit-Bengali.ttf",
                    &[JOINER_GLYPH_INDEX],
                    23,
                );
            }

            #[test]
            fn test_siyam() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-siyam.bn",
                    "bengali/Siyamrupali_1_01.ttf",
                    &[JOINER_GLYPH_INDEX],
                    28,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.bn",
                    "noto/NotoSansBengali-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    11,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.bn",
                    "noto/NotoSerifBengali-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    8,
                );
            }
        }
    }

    mod gurmukhi {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.pa",
            script_tag: "guru",
            lang_tag: "PAN",
        };

        mod indic1 {
            use super::*;

            #[test]
            fn test_saab() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-saab.pa",
                    "gurmukhi/Saab.ttf",
                    &[JOINER_GLYPH_INDEX],
                    77,
                );
            }
        }

        mod indic2 {
            use super::*;

            // High number of failures due to the following issue:
            // https://github.com/n8willis/opentype-shaping-documents/issues/71
            #[test]
            #[cfg(feature = "prince")]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.pa",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    398,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.pa",
                    "noto/NotoSansGurmukhi-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    6,
                );
            }

            #[test]
            #[cfg(feature = "prince")]
            fn test_raavi() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-raavi.pa",
                    "gurmukhi/raavi.ttf",
                    &[JOINER_GLYPH_INDEX],
                    64,
                );
            }
        }
    }

    mod gujarati {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.gu",
            script_tag: "gujr",
            lang_tag: "GUJ",
        };

        // Both Padmaa and Rekha lack the ZWJ glyph, which means that a
        // significant number of failures occur (see comment in `shape_ttf_indic`
        // regarding Prince's splitting of syllable sequences)
        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.gu",
                    "gujarati/lohit_gu.ttf",
                    &[JOINER_GLYPH_INDEX],
                    14,
                );
            }

            #[test]
            fn test_padmaa() {
                // A fair number of syllables in the Gujarati corpus make use
                // of glyphs that the Padmaa font lacks:
                //
                //   * Sign Vocalic L - 88 syllables
                //   * Devanagari Udatta - 6 syllables
                //   * Devanagari Anudatta - 3 syllables
                //
                // For now, just ignore these glyphs when comparing the outputs
                let missing_glyph_index = 0;

                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-padmaa.gu",
                    "gujarati/padmaa.ttf",
                    &[missing_glyph_index, JOINER_GLYPH_INDEX],
                    546,
                );
            }

            #[test]
            fn test_rekha() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-rekha.gu",
                    "gujarati/Rekha.ttf",
                    &[JOINER_GLYPH_INDEX],
                    554,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.gu",
                    "noto/NotoSansGujarati-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    10,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.gu",
                    "noto/NotoSerifGujarati-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    34,
                );
            }

            // Large number of failures due to the lack of ZWJ and
            // dotted circle glyphs
            #[test]
            fn test_samyak() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-samyak.gu",
                    "gujarati/Samyak-Gujarati.ttf",
                    &[JOINER_GLYPH_INDEX],
                    573,
                );
            }
        }
    }

    mod oriya {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.or",
            script_tag: "orya",
            lang_tag: "ORI",
        };

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.or",
                    "oriya/lohit_or.ttf",
                    &[JOINER_GLYPH_INDEX],
                    24,
                );
            }

            // Much like Gujarati's Padmaa and Rekha, the lack of a ZWJ
            // glyph means a large number of failures occur
            #[test]
            fn test_ori1uni() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-ori1uni.or",
                    "oriya/utkalm.ttf",
                    &[JOINER_GLYPH_INDEX],
                    155,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            #[cfg(feature = "prince")]
            fn test_kalinga() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-kalinga.or",
                    "oriya/kalinga.ttf",
                    &[JOINER_GLYPH_INDEX],
                    54,
                );
            }

            #[test]
            #[cfg(feature = "prince")]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.or",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    15,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.or",
                    "noto/NotoSansOriya-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    39,
                );
            }
        }
    }

    mod tamil {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.ta",
            script_tag: "taml",
            lang_tag: "TAM",
        };

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.ta",
                    "tamil/lohit_ta.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            // Missing glyphs, including the dotted circle
            #[test]
            fn test_tamu() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-tamu.ta",
                    "tamil/TAMu_Kalyani.ttf",
                    &[JOINER_GLYPH_INDEX],
                    123,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            #[cfg(feature = "prince")]
            fn test_latha() {
                // Latha doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 202;

                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-latha.ta",
                    "tamil/latha.ttf",
                    &[joiner_glyph_index],
                    1,
                );
            }

            #[test]
            #[cfg(feature = "prince")]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.ta",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.ta",
                    "noto/NotoSansTamil-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.ta",
                    "noto/NotoSerifTamil-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }
    }

    mod telugu {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.te",
            script_tag: "telu",
            lang_tag: "TEL",
        };

        mod indic1 {
            use super::*;

            // Failures are largely due to a handful of missing glyphs
            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.te",
                    "telugu/lohit_te.ttf",
                    &[JOINER_GLYPH_INDEX],
                    73,
                );
            }
        }

        mod indic2 {
            use super::*;

            // Failures are largely due to a handful of missing glyphs
            #[test]
            #[cfg(feature = "prince")]
            fn test_gautami() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-gautami.te",
                    "telugu/gautami.ttf",
                    &[JOINER_GLYPH_INDEX],
                    74,
                );
            }

            #[test]
            fn test_mandali() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-mandali.te",
                    "telugu/Mandali-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    8,
                );
            }

            #[test]
            #[cfg(feature = "prince")]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.te",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    5,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.te",
                    "noto/NotoSansTelugu-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    15,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.te",
                    "noto/NotoSerifTelugu-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    14,
                );
            }
        }
    }

    mod kannada {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.kn",
            script_tag: "knda",
            lang_tag: "KAN",
        };

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.kn",
                    "kannada/lohit_kn.ttf",
                    &[JOINER_GLYPH_INDEX],
                    116,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            #[cfg(feature = "prince")]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.kn",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    70,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.kn",
                    "noto/NotoSansKannada-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    80,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.kn",
                    "noto/NotoSerifKannada-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    82,
                );
            }

            #[test]
            #[cfg(feature = "prince")]
            fn test_tunga() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-tunga.kn",
                    "kannada/tunga.ttf",
                    &[JOINER_GLYPH_INDEX],
                    94,
                );
            }
        }
    }

    mod malayalam {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.ml",
            script_tag: "mlym",
            lang_tag: "MAL",
        };

        mod indic1 {
            use super::*;

            #[test]
            // High number of failures due to the following issue:
            // https://github.com/n8willis/opentype-shaping-documents/issues/71
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.ml",
                    "malayalam/lohit_ml.ttf",
                    &[JOINER_GLYPH_INDEX],
                    101,
                );
            }

            #[test]
            fn test_rachana() {
                // Indic1 Rachana doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-rachana-indic1.ml",
                    "malayalam/Rachana_w01.ttf",
                    &[joiner_glyph_index],
                    10,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_chilanka() {
                // Chilanka doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 2;

                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-chilanka.ml",
                    "malayalam/Chilanka-Regular.ttf",
                    &[joiner_glyph_index],
                    9,
                );
            }

            #[test]
            fn test_dyuthi() {
                // Dyuthi doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-dyuthi.ml",
                    "malayalam/Dyuthi-Regular.ttf",
                    &[joiner_glyph_index],
                    43,
                );
            }

            #[test]
            // High number of failures, due to differences in pre-base
            // matra / reordering consonant final positions. However, our
            // output is (visually) _almost_ identical to Uniscribe's
            #[cfg(feature = "prince")]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.ml",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    445,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.ml",
                    "noto/NotoSansMalayalam-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    159,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.ml",
                    "noto/NotoSerifMalayalam-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    15,
                );
            }

            #[test]
            fn test_rachana() {
                // Indic2 Rachana doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-rachana-indic2.ml",
                    "malayalam/Rachana-Regular.ttf",
                    &[joiner_glyph_index],
                    14,
                );
            }
        }
    }

    mod sinhala {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.si",
            script_tag: "sinh",
            lang_tag: "SNH",
        };

        #[cfg(feature = "prince")]
        mod indic1 {
            use super::*;

            // The majority of errors appear to be a result of us not supporting Uniscribe-style
            // matra decomposition. If Uniscribe compatibility is disabled in HarfBuzz, the number
            // of errors drops from 2110 to 131. A sampling of these errors show that they do not
            // differ visually, but their indices do - a result of the PSTF feature being applied
            // to the Uniscribe-style decomposed matras.
            #[test]
            fn test_iskoola() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-iskoola.si",
                    "sinhala/iskpota.ttf",
                    &[JOINER_GLYPH_INDEX],
                    2110,
                );
            }
        }

        mod indic2 {
            use super::*;

            // Uniscribe compatibility (see comment above). If disabled, the number of errors drops
            // from 1979 to 131.
            #[test]
            #[cfg(feature = "prince")]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.si",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    1979,
                );
            }

            // The majority of errors appear to be a result of us not skipping ZWJs in backtrack/
            // lookahead sequences (note: not a Uniscribe feature). In particular, this prevents
            // "Rakaaraansaya" from undergoing further substitutions.
            // https://github.com/n8willis/opentype-shaping-documents/issues/111.
            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.si",
                    "noto/NotoSansSinhala-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    349,
                );
            }

            // ZWJ skipping (see comment above).
            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.si",
                    "noto/NotoSerifSinhala-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    347,
                );
            }
        }
    }
}

// Skip all DirectWrite tests for now.
//
// Our DirectWrite harness occasionally omits the `|` separator, which
// causes integer overflows during the parsing process. These tests
// have been explicitly marked with `#[ignore]`. The tests that run fine
// should also be considered suspect
#[cfg(notest)] // Bogus flag to skip test compilation
mod directwrite {
    use super::*;

    const JOINER_GLYPH_INDEX: u16 = 3;

    mod devanagari {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.hi",
            script_tag: "deva",
            lang_tag: "HIN",
        };

        mod indic1 {
            use super::*;

            // Expected output is broken
            #[ignore]
            #[test]
            fn test_sahadeva() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-sahadeva.hi",
                    "devanagari/sahadeva.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_annapurna() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-annapurna.hi",
                    "devanagari/AnnapurnaSIL-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    1513,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.hi",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    1517,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.hi",
                    "noto/NotoSansDevanagari-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    1550,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.hi",
                    "noto/NotoSerifDevanagari-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    1514,
                );
            }
        }
    }

    mod bengali {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.bn",
            script_tag: "beng",
            lang_tag: "BEN",
        };

        mod indic2 {
            use super::*;

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.bn",
                    "noto/NotoSansBengali-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    564,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.bn",
                    "noto/NotoSerifBengali-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    562,
                );
            }
        }
    }

    mod gurmukhi {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.pa",
            script_tag: "guru",
            lang_tag: "PAN",
        };

        mod indic1 {
            use super::*;

            #[ignore]
            #[test]
            fn test_saab() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-saab.pa",
                    "gurmukhi/Saab.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.pa",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    777,
                );
            }

            #[ignore]
            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.pa",
                    "noto/NotoSansGurmukhi-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }
    }

    mod gujarati {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.gu",
            script_tag: "gujr",
            lang_tag: "GUJ",
        };

        mod indic2 {
            use super::*;

            #[ignore]
            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.gu",
                    "noto/NotoSansGujarati-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[ignore]
            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.gu",
                    "noto/NotoSerifGujarati-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }
    }

    mod oriya {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.or",
            script_tag: "orya",
            lang_tag: "ORI",
        };

        mod indic2 {
            use super::*;

            #[ignore]
            #[test]
            fn test_kalinga() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-kalinga.or",
                    "oriya/kalinga.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.or",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    220,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.or",
                    "noto/NotoSansOriya-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    206,
                );
            }
        }
    }

    mod tamil {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.ta",
            script_tag: "taml",
            lang_tag: "TAM",
        };

        mod indic1 {
            use super::*;

            #[ignore]
            #[test]
            fn test_tamu() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-tamu.ta",
                    "tamil/TAMu_Kalyani.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.ta",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    353,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.ta",
                    "noto/NotoSansTamil-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    353,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.ta",
                    "noto/NotoSerifTamil-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    353,
                );
            }
        }
    }

    mod telugu {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.te",
            script_tag: "telu",
            lang_tag: "TEL",
        };

        mod indic2 {
            use super::*;

            #[ignore]
            #[test]
            fn test_mandali() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-mandali.te",
                    "telugu/Mandali-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[ignore]
            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.te",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.te",
                    "noto/NotoSansTelugu-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    351,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.te",
                    "noto/NotoSerifTelugu-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    357,
                );
            }
        }
    }

    mod kannada {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.kn",
            script_tag: "knda",
            lang_tag: "KAN",
        };

        mod indic2 {
            use super::*;

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.kn",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    546,
                );
            }

            #[ignore]
            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.kn",
                    "noto/NotoSansKannada-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.kn",
                    "noto/NotoSerifKannada-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    462,
                );
            }
        }
    }

    mod malayalam {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.ml",
            script_tag: "mlym",
            lang_tag: "MAL",
        };

        mod indic1 {
            use super::*;

            #[ignore]
            #[test]
            fn test_rachana() {
                // Indic1 Rachana doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    &TEST_DATA,
                    "directwrite/good-rachana-indic1.ml",
                    "malayalam/Rachana_w01.ttf",
                    &[joiner_glyph_index],
                    0,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[ignore]
            #[test]
            fn test_chilanka() {
                // Chilanka doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 2;

                run_test(
                    &TEST_DATA,
                    "directwrite/good-chilanka.ml",
                    "malayalam/Chilanka-Regular.ttf",
                    &[joiner_glyph_index],
                    0,
                );
            }

            #[ignore]
            #[test]
            fn test_dyuthi() {
                // Dyuthi doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    &TEST_DATA,
                    "directwrite/good-dyuthi.ml",
                    "malayalam/Dyuthi-Regular.ttf",
                    &[joiner_glyph_index],
                    44,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.ml",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    871,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.ml",
                    "noto/NotoSansMalayalam-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    791,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.ml",
                    "noto/NotoSerifMalayalam-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    668,
                );
            }

            #[ignore]
            #[test]
            fn test_rachana() {
                // Indic2 Rachana doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    &TEST_DATA,
                    "directwrite/good-rachana-indic2.ml",
                    "malayalam/Rachana-Regular.ttf",
                    &[joiner_glyph_index],
                    0,
                );
            }
        }
    }
}

#[cfg(test)]
mod bad {
    use super::*;

    mod devanagari {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.hi",
            script_tag: "deva",
            lang_tag: "HIN",
        };

        #[test]
        fn test_annapurna() {
            run_test_bad(&TEST_DATA, "devanagari/AnnapurnaSIL-Regular.ttf");
        }

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "devanagari/lohit_hi.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_mangal() {
            run_test_bad(&TEST_DATA, "devanagari/mangal.ttf");
        }

        #[test]
        fn test_sahadeva() {
            run_test_bad(&TEST_DATA, "devanagari/sahadeva.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansDevanagari-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifDevanagari-Regular.ttf");
        }
    }

    mod bengali {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.bn",
            script_tag: "beng",
            lang_tag: "BEN",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "bengali/Lohit-Bengali.ttf");
        }

        #[test]
        fn test_siyam() {
            run_test_bad(&TEST_DATA, "bengali/Siyamrupali_1_01.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansBengali-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifBengali-Regular.ttf");
        }
    }

    mod gurmukhi {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.pa",
            script_tag: "guru",
            lang_tag: "PAN",
        };

        #[test]
        fn test_saab() {
            run_test_bad(&TEST_DATA, "gurmukhi/Saab.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansGurmukhi-Regular.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_raavi() {
            run_test_bad(&TEST_DATA, "gurmukhi/raavi.ttf");
        }
    }

    mod gujarati {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.gu",
            script_tag: "gujr",
            lang_tag: "GUJ",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "gujarati/lohit_gu.ttf");
        }

        #[test]
        fn test_padmaa() {
            run_test_bad(&TEST_DATA, "gujarati/padmaa.ttf");
        }

        #[test]
        fn test_samyak() {
            run_test_bad(&TEST_DATA, "gujarati/Samyak-Gujarati.ttf");
        }

        #[test]
        fn test_rekha() {
            run_test_bad(&TEST_DATA, "gujarati/Rekha.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansGujarati-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifGujarati-Regular.ttf");
        }
    }

    mod oriya {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.or",
            script_tag: "orya",
            lang_tag: "ORI",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "oriya/lohit_or.ttf");
        }

        #[test]
        fn test_ori1uni() {
            run_test_bad(&TEST_DATA, "oriya/utkalm.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_kalinga() {
            run_test_bad(&TEST_DATA, "oriya/kalinga.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansOriya-Regular.ttf");
        }
    }

    mod tamil {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.ta",
            script_tag: "taml",
            lang_tag: "TAM",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "tamil/lohit_ta.ttf");
        }

        #[test]
        fn test_tamu() {
            run_test_bad(&TEST_DATA, "tamil/TAMu_Kalyani.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_latha() {
            run_test_bad(&TEST_DATA, "tamil/latha.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansTamil-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifTamil-Regular.ttf");
        }
    }

    mod telugu {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.te",
            script_tag: "telu",
            lang_tag: "TEL",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "telugu/lohit_te.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_gautami() {
            run_test_bad(&TEST_DATA, "telugu/gautami.ttf");
        }

        #[test]
        fn test_mandali() {
            run_test_bad(&TEST_DATA, "telugu/Mandali-Regular.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansTelugu-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifTelugu-Regular.ttf");
        }
    }

    mod kannada {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.kn",
            script_tag: "knda",
            lang_tag: "KAN",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "kannada/lohit_kn.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansKannada-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifKannada-Regular.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_tunga() {
            run_test_bad(&TEST_DATA, "kannada/tunga.ttf");
        }
    }

    mod malayalam {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.ml",
            script_tag: "mlym",
            lang_tag: "MAL",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "malayalam/lohit_ml.ttf");
        }

        #[test]
        fn test_rachana_indic1() {
            run_test_bad(&TEST_DATA, "malayalam/Rachana_w01.ttf");
        }

        #[test]
        fn test_chilanka() {
            run_test_bad(&TEST_DATA, "malayalam/Chilanka-Regular.ttf");
        }

        #[test]
        fn test_dyuthi() {
            run_test_bad(&TEST_DATA, "malayalam/Dyuthi-Regular.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansMalayalam-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifMalayalam-Regular.ttf");
        }

        #[test]
        fn test_rachana_indic2() {
            run_test_bad(&TEST_DATA, "malayalam/Rachana-Regular.ttf");
        }
    }

    mod sinhala {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.si",
            script_tag: "sinh",
            lang_tag: "SNH",
        };

        #[test]
        #[cfg(feature = "prince")]
        fn test_iskoola() {
            run_test_bad(&TEST_DATA, "sinhala/iskpota.ttf");
        }

        #[test]
        #[cfg(feature = "prince")]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansSinhala-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifSinhala-Regular.ttf");
        }
    }
}

mod common;

use std::io::BufRead;
use std::path::Path;
use std::rc::Rc;

use lazy_static::lazy_static;
use regex::Regex;

use allsorts::binary::read::ReadScope;
use allsorts::error::{ParseError, ShapingError};
use allsorts::font_data_impl::FontDataImpl;
use allsorts::gsub::{gsub_apply_default, GlyphOrigin, RawGlyph};
use allsorts::indic;
use allsorts::tables::cmap::CmapSubtable;
use allsorts::tables::{FontTableProvider, OpenTypeFile};
use allsorts::tag;

// Variant of `bin/shape::shape_ttf`
fn shape_ttf_indic<'a, T: FontTableProvider>(
    font: &mut FontDataImpl<T>,
    script_tag: u32,
    lang_tag: u32,
    text: &str,
) -> Result<Vec<u16>, ShapingError> {
    let cmap_subtable_data = font.cmap_subtable_data().to_vec();
    let cmap_subtable = ReadScope::new(&cmap_subtable_data)
        .read::<CmapSubtable<'_>>()
        .expect("no suitable cmap subtable");

    // Run Indic-specific preprocessing prior to shaping
    let mut chars = text.chars().collect();
    indic::preprocess_indic(&mut chars);

    let res_opt_glyphs: Result<Vec<_>, _> = chars
        .iter()
        .map(|ch| map_glyph(&cmap_subtable, *ch))
        .collect();
    let mut opt_glyphs = res_opt_glyphs?;

    // Mimic the existing behaviour of Prince, which is to split a sequence if
    // a font is missing a character glyph. We previously copied the behaviour
    // in `shape.rs`, where the missing glyphs are merely omitted. This can be
    // misleading, especially when comparing the glyph indices as generated by
    // the corpus test against the PDF as generated by Prince.
    //
    // Example:
    //   Assumptions:
    //     1. A and B can form a ligature A+B iff D is base.
    //     2. A+B and C can form a ligature A+B+C iff D is base.
    //
    //   Test sequence: [A, B, Missing, C, D]
    //          Prince: [A, B] [Missing] [C, D] - No ligation. The sequence is split, and
    //                                            D is no longer the base of A and B
    //        shape.rs: [A+B+C, D] - Unexpected ligature; doesn't match Prince's PDF output
    let mut glyphs: Vec<Vec<RawGlyph<()>>> = Vec::new();
    while !opt_glyphs.is_empty() {
        let i = opt_glyphs
            .iter()
            .position(Option::is_none)
            .unwrap_or(opt_glyphs.len() - 1);

        let sub = opt_glyphs.drain(..=i).flatten().collect(); // `flatten` removes any end `None`s
        glyphs.push(sub);
    }

    let gsub_cache = font
        .gsub_cache()
        .expect("unable to get gsub cache")
        .expect("missing gsub table");
    let gdef_table = font.gdef_table().expect("unable to get gdef table");
    let vertical = false;

    for mut gs in glyphs.iter_mut() {
        gsub_apply_default(
            &|| make_dotted_circle(&cmap_subtable),
            &gsub_cache,
            gdef_table.as_ref().map(Rc::as_ref),
            script_tag,
            lang_tag,
            vertical,
            &mut gs,
        )?;
    }

    let glyph_indices = glyphs
        .into_iter()
        .flatten()
        .map(|g| g.glyph_index.unwrap_or(0)) // Set to 0 if `None`, but shouldn't happen
        .collect();

    Ok(glyph_indices)
}

// Copy of `bin/shape::make_dotted_circle`
fn make_dotted_circle(cmap_subtable: &CmapSubtable) -> Vec<RawGlyph<()>> {
    match map_glyph(cmap_subtable, '\u{25CC}') {
        Ok(Some(raw_glyph)) => vec![raw_glyph],
        _ => Vec::new(),
    }
}

// Variant of `bin/shape::map_glyph`
fn map_glyph(cmap_subtable: &CmapSubtable, ch: char) -> Result<Option<RawGlyph<()>>, ParseError> {
    // Specially handle ZWNJ character, so as to mimic existing Prince behaviour
    if ch == '\u{200C}' {
        Ok(Some(make_zwnj()))
    } else {
        cmap_subtable
            .map_glyph(ch as u32)
            .map(|opt_index| opt_index.map(|index| make_glyph(ch, index)))
    }
}

// Copy of `bin/shape::make_glyph`
fn make_glyph(ch: char, glyph_index: u16) -> RawGlyph<()> {
    RawGlyph {
        unicodes: vec![ch],
        glyph_index: Some(glyph_index),
        liga_component_pos: 0,
        glyph_origin: GlyphOrigin::Char(ch),
        small_caps: false,
        multi_subst_dup: false,
        is_vert_alt: false,
        fake_bold: false,
        fake_italic: false,
        extra_data: (),
    }
}

fn make_zwnj() -> RawGlyph<()> {
    RawGlyph {
        unicodes: vec![],
        glyph_index: None,
        liga_component_pos: 0,
        glyph_origin: GlyphOrigin::Char('\u{200C}'),
        small_caps: false,
        multi_subst_dup: false,
        is_vert_alt: false,
        fake_bold: false,
        fake_italic: false,
        extra_data: (),
    }
}

fn read_fixture_inputs<P: AsRef<Path>>(path: P) -> Vec<u8> {
    common::read_fixture(Path::new("tests/indic").join(path))
}

fn read_fixture_font<P: AsRef<Path>>(path: P) -> Vec<u8> {
    common::read_fixture(Path::new("../../../data/fonts").join(path))
}

fn read_inputs<P: AsRef<Path>>(inputs_path: P) -> Vec<String> {
    read_fixture_inputs(inputs_path)
        .lines()
        .collect::<Result<_, _>>()
        .expect("error reading inputs")
}

fn parse_expected_output(expected_output: &str, ignore: &[u16]) -> (Vec<u16>, Option<String>) {
    fn parse(s: &str, ignore: &[u16]) -> Vec<u16> {
        s.split("|")
            .map(|s| s.parse::<u16>().expect("error parsing glyph index"))
            .filter(|i| ignore.is_empty() || !ignore.contains(i))
            .collect()
    }

    lazy_static! {
        static ref REGEX: Regex = Regex::new(r"^\[(\d+(?:\|\d+)*)\](?:\s*:\s*(.*))?$").unwrap();
    }

    if let Some(captures) = REGEX.captures(expected_output) {
        let indices = parse(&captures[1], ignore);
        let reason = captures.get(2).map(|s| String::from(s.as_str()));

        (indices, reason)
    } else {
        panic!("invalid expected output format: {:?}", expected_output);
    }
}

fn parse_expected_outputs<P: AsRef<Path>>(
    expected_outputs_path: P,
    ignore: &[u16],
) -> Vec<(Vec<u16>, Option<String>)> {
    read_fixture_inputs(expected_outputs_path)
        .lines()
        .map(|line| line.expect("error reading expected output"))
        .map(|line| parse_expected_output(&line, ignore))
        .collect()
}

fn run_test<P: AsRef<Path>>(
    test_data: &TestData,
    expected_outputs_path: P,
    font_path: P,
    ignore: &[u16],
    expected_num_fail: usize,
) {
    let inputs = read_inputs(test_data.inputs_path);
    let expected_outputs = parse_expected_outputs(expected_outputs_path, ignore);
    assert_eq!(expected_outputs.len(), inputs.len());

    let font_buffer = read_fixture_font(font_path);
    let opentype_file = ReadScope::new(&font_buffer)
        .read::<OpenTypeFile<'_>>()
        .unwrap();
    let font_table_provider = opentype_file
        .font_provider(0)
        .expect("error reading font file");
    let mut font = FontDataImpl::new(Box::new(font_table_provider))
        .expect("error reading font data")
        .expect("missing required font tables");

    let script_tag = tag::from_string(test_data.script_tag).expect("invalid script tag");
    let lang_tag = tag::from_string(test_data.lang_tag).expect("invalid language tag");

    let mut num_pass = 0;
    let mut num_fail = 0;
    for (i, input) in inputs.iter().enumerate() {
        let actual_output = shape_ttf_indic(&mut font, script_tag, lang_tag, &input);

        match (&actual_output, &expected_outputs[i]) {
            (Ok(actual_output), (expected_output, reason)) if actual_output == expected_output => {
                // If a successful test has a (failure) reason attached,
                // we may want to know about it
                if let Some(reason) = reason {
                    println!("[SUCCESS]");
                    println!("line {:0>5}: {}", i + 1, input);
                    println!("    reason: {}", reason);
                    println!();
                }

                num_pass += 1;
            }
            (result, (expected_output, reason)) => {
                println!("line {:0>5}: {}", i + 1, input);
                println!("  expected: {:?}", expected_output);
                match result {
                    Ok(actual_output) => println!("    actual: {:?}", actual_output),
                    Err(error) => println!("    actual: {:?}", error),
                };
                if let Some(reason) = reason {
                    println!("    reason: {}", reason);
                }
                println!();

                num_fail += 1;
            }
        }
    }

    println!("total: {:?}", inputs.len());
    println!(" pass: {:?}", num_pass);
    println!(" fail: {:?}", num_fail);

    assert_eq!(num_pass + num_fail, inputs.len());
    assert_eq!(num_fail, expected_num_fail);
}

fn run_test_bad<P: AsRef<Path>>(test_data: &TestData, font_path: P) {
    let inputs = read_inputs(test_data.inputs_path);

    let font_buffer = read_fixture_font(font_path);
    let opentype_file = ReadScope::new(&font_buffer)
        .read::<OpenTypeFile<'_>>()
        .unwrap();
    let font_table_provider = opentype_file
        .font_provider(0)
        .expect("error reading font file");
    let mut font = FontDataImpl::new(Box::new(font_table_provider))
        .expect("error reading font data")
        .expect("missing required font tables");
    let script_tag = tag::from_string(test_data.script_tag).expect("invalid script tag");
    let lang_tag = tag::from_string(test_data.lang_tag).expect("invalid language tag");

    for input in inputs.iter() {
        let _actual_output = shape_ttf_indic(&mut font, script_tag, lang_tag, &input);
    }
}

struct TestData<'a> {
    inputs_path: &'a str,
    script_tag: &'a str,
    lang_tag: &'a str,
}

// Run with `-- --nocapture` to view details of failed test cases
#[cfg(test)]
mod harfbuzz {
    use super::*;

    // HarfBuzz replaces joiner glyphs with the space glyph, which we
    // omit from the output comparisons as our (current) approach is
    // different (we strip all joiners from the glyph buffer after GSUB)
    const JOINER_GLYPH_INDEX: u16 = 3;

    mod devanagari {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.hi",
            script_tag: "deva",
            lang_tag: "HIN",
        };

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.hi",
                    "devanagari/lohit_hi.ttf",
                    &[JOINER_GLYPH_INDEX],
                    32,
                );
            }

            #[test]
            fn test_mangal() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-mangal.hi",
                    "devanagari/mangal.ttf",
                    &[JOINER_GLYPH_INDEX],
                    84,
                );
            }

            #[test]
            fn test_sahadeva() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-sahadeva.hi",
                    "devanagari/sahadeva.ttf",
                    &[JOINER_GLYPH_INDEX],
                    84,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_annapurna() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-annapurna.hi",
                    "devanagari/AnnapurnaSIL-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    6,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.hi",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    35,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.hi",
                    "noto/NotoSansDevanagari-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    9,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.hi",
                    "noto/NotoSerifDevanagari-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    29,
                );
            }
        }
    }

    mod bengali {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.bn",
            script_tag: "beng",
            lang_tag: "BEN",
        };

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.bn",
                    "bengali/Lohit-Bengali.ttf",
                    &[JOINER_GLYPH_INDEX],
                    25,
                );
            }

            #[test]
            fn test_siyam() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-siyam.bn",
                    "bengali/Siyamrupali_1_01.ttf",
                    &[JOINER_GLYPH_INDEX],
                    28,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.bn",
                    "noto/NotoSansBengali-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    12,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.bn",
                    "noto/NotoSerifBengali-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    9,
                );
            }
        }
    }

    mod gurmukhi {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.pa",
            script_tag: "guru",
            lang_tag: "PAN",
        };

        mod indic1 {
            use super::*;

            #[test]
            fn test_saab() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-saab.pa",
                    "gurmukhi/Saab.ttf",
                    &[JOINER_GLYPH_INDEX],
                    58,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            // High number of failures due to the following issue:
            // https://github.com/n8willis/opentype-shaping-documents/issues/71
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.pa",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    372,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.pa",
                    "noto/NotoSansGurmukhi-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    4,
                );
            }

            #[test]
            fn test_raavi() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-raavi.pa",
                    "gurmukhi/raavi.ttf",
                    &[JOINER_GLYPH_INDEX],
                    45,
                );
            }
        }
    }

    mod gujarati {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.gu",
            script_tag: "gujr",
            lang_tag: "GUJ",
        };

        // Both Padmaa and Rekha lack the ZWJ glyph, which means that a
        // significant number of failures occur (see comment in `shape_ttf_indic`
        // regarding Prince's splitting of syllable sequences)
        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.gu",
                    "gujarati/lohit_gu.ttf",
                    &[JOINER_GLYPH_INDEX],
                    15,
                );
            }

            #[test]
            fn test_padmaa() {
                // A fair number of syllables in the Gujarati corpus make use
                // of glyphs that the Padmaa font lacks:
                //
                //   * Sign Vocalic L - 88 syllables
                //   * Devanagari Udatta - 6 syllables
                //   * Devanagari Anudatta - 3 syllables
                //
                // For now, just ignore these glyphs when comparing the outputs
                let missing_glyph_index = 0;

                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-padmaa.gu",
                    "gujarati/padmaa.ttf",
                    &[missing_glyph_index, JOINER_GLYPH_INDEX],
                    550,
                );
            }

            #[test]
            fn test_rekha() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-rekha.gu",
                    "gujarati/Rekha.ttf",
                    &[JOINER_GLYPH_INDEX],
                    558,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.gu",
                    "noto/NotoSansGujarati-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    12,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.gu",
                    "noto/NotoSerifGujarati-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    35,
                );
            }

            // Large number of failures due to the lack of ZWJ and
            // dotted circle glyphs
            #[test]
            fn test_samyak() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-samyak.gu",
                    "gujarati/Samyak-Gujarati.ttf",
                    &[JOINER_GLYPH_INDEX],
                    625,
                );
            }
        }
    }

    mod oriya {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.or",
            script_tag: "orya",
            lang_tag: "ORI",
        };

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.or",
                    "oriya/lohit_or.ttf",
                    &[JOINER_GLYPH_INDEX],
                    25,
                );
            }

            // Much like Gujarati's Padmaa and Rekha, the lack of a ZWJ
            // glyph means a large number of failures occur
            #[test]
            fn test_ori1uni() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-ori1uni.or",
                    "oriya/utkalm.ttf",
                    &[JOINER_GLYPH_INDEX],
                    147,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_kalinga() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-kalinga.or",
                    "oriya/kalinga.ttf",
                    &[JOINER_GLYPH_INDEX],
                    51,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.or",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    14,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.or",
                    "noto/NotoSansOriya-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    36,
                );
            }
        }
    }

    mod tamil {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.ta",
            script_tag: "taml",
            lang_tag: "TAM",
        };

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.ta",
                    "tamil/lohit_ta.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            // Missing glyphs, including the dotted circle
            #[test]
            fn test_tamu() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-tamu.ta",
                    "tamil/TAMu_Kalyani.ttf",
                    &[JOINER_GLYPH_INDEX],
                    167,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_latha() {
                // Latha doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 202;

                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-latha.ta",
                    "tamil/latha.ttf",
                    &[joiner_glyph_index],
                    1,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.ta",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.ta",
                    "noto/NotoSansTamil-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.ta",
                    "noto/NotoSerifTamil-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }
    }

    mod telugu {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.te",
            script_tag: "telu",
            lang_tag: "TEL",
        };

        mod indic1 {
            use super::*;

            // Failures are largely due to a handful of missing glyphs
            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.te",
                    "telugu/lohit_te.ttf",
                    &[JOINER_GLYPH_INDEX],
                    93,
                );
            }
        }

        mod indic2 {
            use super::*;

            // Failures are largely due to a handful of missing glyphs
            #[test]
            fn test_gautami() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-gautami.te",
                    "telugu/gautami.ttf",
                    &[JOINER_GLYPH_INDEX],
                    94,
                );
            }

            #[test]
            fn test_mandali() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-mandali.te",
                    "telugu/Mandali-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    10,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.te",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    7,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.te",
                    "noto/NotoSansTelugu-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    17,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.te",
                    "noto/NotoSerifTelugu-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    16,
                );
            }
        }
    }

    mod kannada {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.kn",
            script_tag: "knda",
            lang_tag: "KAN",
        };

        mod indic1 {
            use super::*;

            #[test]
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.kn",
                    "kannada/lohit_kn.ttf",
                    &[JOINER_GLYPH_INDEX],
                    118,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.kn",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    104,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.kn",
                    "noto/NotoSansKannada-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    79,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.kn",
                    "noto/NotoSerifKannada-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    81,
                );
            }

            #[test]
            fn test_tunga() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-tunga.kn",
                    "kannada/tunga.ttf",
                    &[JOINER_GLYPH_INDEX],
                    90,
                );
            }
        }
    }

    mod malayalam {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.ml",
            script_tag: "mlym",
            lang_tag: "MAL",
        };

        mod indic1 {
            use super::*;

            #[test]
            // High number of failures due to the following issue:
            // https://github.com/n8willis/opentype-shaping-documents/issues/71
            fn test_lohit() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-lohit.ml",
                    "malayalam/lohit_ml.ttf",
                    &[JOINER_GLYPH_INDEX],
                    97,
                );
            }

            #[test]
            fn test_rachana() {
                // Indic1 Rachana doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-rachana-indic1.ml",
                    "malayalam/Rachana_w01.ttf",
                    &[joiner_glyph_index],
                    11,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_chilanka() {
                // Chilanka doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 2;

                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-chilanka.ml",
                    "malayalam/Chilanka-Regular.ttf",
                    &[joiner_glyph_index],
                    10,
                );
            }

            #[test]
            fn test_dyuthi() {
                // Dyuthi doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-dyuthi.ml",
                    "malayalam/Dyuthi-Regular.ttf",
                    &[joiner_glyph_index],
                    44,
                );
            }

            #[test]
            // High number of failures, due to differences in pre-base
            // matra / reordering consonant final positions. However, our
            // output is (visually) _almost_ identical to Uniscribe's.
            // Only three tests differ: 6570, 6571, 12522
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-nirmala.ml",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    380,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-sans.ml",
                    "noto/NotoSansMalayalam-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    150,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-noto-serif.ml",
                    "noto/NotoSerifMalayalam-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    16,
                );
            }

            #[test]
            fn test_rachana() {
                // Indic2 Rachana doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    &TEST_DATA,
                    "harfbuzz/good-rachana-indic2.ml",
                    "malayalam/Rachana-Regular.ttf",
                    &[joiner_glyph_index],
                    15,
                );
            }
        }
    }
}

// Skip all DirectWrite tests for now.
//
// Our DirectWrite harness occasionally omits the `|` separator, which
// causes integer overflows during the parsing process. These tests
// have been explicitly marked with `#[ignore]`. The tests that run fine
// should also be considered suspect
#[cfg(notest)] // Bogus flag to skip test compilation
mod directwrite {
    use super::*;

    const JOINER_GLYPH_INDEX: u16 = 3;

    mod devanagari {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.hi",
            script_tag: "deva",
            lang_tag: "HIN",
        };

        mod indic1 {
            use super::*;

            // Expected output is broken
            #[ignore]
            #[test]
            fn test_sahadeva() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-sahadeva.hi",
                    "devanagari/sahadeva.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_annapurna() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-annapurna.hi",
                    "devanagari/AnnapurnaSIL-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    1513,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.hi",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    1517,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.hi",
                    "noto/NotoSansDevanagari-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    1550,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.hi",
                    "noto/NotoSerifDevanagari-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    1514,
                );
            }
        }
    }

    mod bengali {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.bn",
            script_tag: "beng",
            lang_tag: "BEN",
        };

        mod indic2 {
            use super::*;

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.bn",
                    "noto/NotoSansBengali-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    564,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.bn",
                    "noto/NotoSerifBengali-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    562,
                );
            }
        }
    }

    mod gurmukhi {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.pa",
            script_tag: "guru",
            lang_tag: "PAN",
        };

        mod indic1 {
            use super::*;

            #[ignore]
            #[test]
            fn test_saab() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-saab.pa",
                    "gurmukhi/Saab.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.pa",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    777,
                );
            }

            #[ignore]
            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.pa",
                    "noto/NotoSansGurmukhi-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }
    }

    mod gujarati {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.gu",
            script_tag: "gujr",
            lang_tag: "GUJ",
        };

        mod indic2 {
            use super::*;

            #[ignore]
            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.gu",
                    "noto/NotoSansGujarati-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[ignore]
            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.gu",
                    "noto/NotoSerifGujarati-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }
    }

    mod oriya {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.or",
            script_tag: "orya",
            lang_tag: "ORI",
        };

        mod indic2 {
            use super::*;

            #[ignore]
            #[test]
            fn test_kalinga() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-kalinga.or",
                    "oriya/kalinga.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.or",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    220,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.or",
                    "noto/NotoSansOriya-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    206,
                );
            }
        }
    }

    mod tamil {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.ta",
            script_tag: "taml",
            lang_tag: "TAM",
        };

        mod indic1 {
            use super::*;

            #[ignore]
            #[test]
            fn test_tamu() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-tamu.ta",
                    "tamil/TAMu_Kalyani.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.ta",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    353,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.ta",
                    "noto/NotoSansTamil-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    353,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.ta",
                    "noto/NotoSerifTamil-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    353,
                );
            }
        }
    }

    mod telugu {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.te",
            script_tag: "telu",
            lang_tag: "TEL",
        };

        mod indic2 {
            use super::*;

            #[ignore]
            #[test]
            fn test_mandali() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-mandali.te",
                    "telugu/Mandali-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[ignore]
            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.te",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.te",
                    "noto/NotoSansTelugu-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    351,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.te",
                    "noto/NotoSerifTelugu-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    357,
                );
            }
        }
    }

    mod kannada {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.kn",
            script_tag: "knda",
            lang_tag: "KAN",
        };

        mod indic2 {
            use super::*;

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.kn",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    546,
                );
            }

            #[ignore]
            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.kn",
                    "noto/NotoSansKannada-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    0,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.kn",
                    "noto/NotoSerifKannada-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    462,
                );
            }
        }
    }

    mod malayalam {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "good.ml",
            script_tag: "mlym",
            lang_tag: "MAL",
        };

        mod indic1 {
            use super::*;

            #[ignore]
            #[test]
            fn test_rachana() {
                // Indic1 Rachana doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    &TEST_DATA,
                    "directwrite/good-rachana-indic1.ml",
                    "malayalam/Rachana_w01.ttf",
                    &[joiner_glyph_index],
                    0,
                );
            }
        }

        mod indic2 {
            use super::*;

            #[ignore]
            #[test]
            fn test_chilanka() {
                // Chilanka doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 2;

                run_test(
                    &TEST_DATA,
                    "directwrite/good-chilanka.ml",
                    "malayalam/Chilanka-Regular.ttf",
                    &[joiner_glyph_index],
                    0,
                );
            }

            #[ignore]
            #[test]
            fn test_dyuthi() {
                // Dyuthi doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    &TEST_DATA,
                    "directwrite/good-dyuthi.ml",
                    "malayalam/Dyuthi-Regular.ttf",
                    &[joiner_glyph_index],
                    44,
                );
            }

            #[test]
            fn test_nirmala() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-nirmala.ml",
                    "indic/Nirmala.ttf",
                    &[JOINER_GLYPH_INDEX],
                    871,
                );
            }

            #[test]
            fn test_noto_sans() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-sans.ml",
                    "noto/NotoSansMalayalam-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    791,
                );
            }

            #[test]
            fn test_noto_serif() {
                run_test(
                    &TEST_DATA,
                    "directwrite/good-noto-serif.ml",
                    "noto/NotoSerifMalayalam-Regular.ttf",
                    &[JOINER_GLYPH_INDEX],
                    668,
                );
            }

            #[ignore]
            #[test]
            fn test_rachana() {
                // Indic2 Rachana doesn't use the default index = 3 for the space glyph
                let joiner_glyph_index = 4;

                run_test(
                    &TEST_DATA,
                    "directwrite/good-rachana-indic2.ml",
                    "malayalam/Rachana-Regular.ttf",
                    &[joiner_glyph_index],
                    0,
                );
            }
        }
    }
}

#[cfg(test)]
mod bad {
    use super::*;

    mod devanagari {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.hi",
            script_tag: "deva",
            lang_tag: "HIN",
        };

        #[test]
        fn test_annapurna() {
            run_test_bad(&TEST_DATA, "devanagari/AnnapurnaSIL-Regular.ttf");
        }

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "devanagari/lohit_hi.ttf");
        }

        #[test]
        fn test_mangal() {
            run_test_bad(&TEST_DATA, "devanagari/mangal.ttf");
        }

        #[test]
        fn test_sahadeva() {
            run_test_bad(&TEST_DATA, "devanagari/sahadeva.ttf");
        }

        #[test]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansDevanagari-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifDevanagari-Regular.ttf");
        }
    }

    mod bengali {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.bn",
            script_tag: "beng",
            lang_tag: "BEN",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "bengali/Lohit-Bengali.ttf");
        }

        #[test]
        fn test_siyam() {
            run_test_bad(&TEST_DATA, "bengali/Siyamrupali_1_01.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansBengali-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifBengali-Regular.ttf");
        }
    }

    mod gurmukhi {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.pa",
            script_tag: "guru",
            lang_tag: "PAN",
        };

        #[test]
        fn test_saab() {
            run_test_bad(&TEST_DATA, "gurmukhi/Saab.ttf");
        }

        #[test]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansGurmukhi-Regular.ttf");
        }

        #[test]
        fn test_raavi() {
            run_test_bad(&TEST_DATA, "gurmukhi/raavi.ttf");
        }
    }

    mod gujarati {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.gu",
            script_tag: "gujr",
            lang_tag: "GUJ",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "gujarati/lohit_gu.ttf");
        }

        #[test]
        fn test_padmaa() {
            run_test_bad(&TEST_DATA, "gujarati/padmaa.ttf");
        }

        #[test]
        fn test_samyak() {
            run_test_bad(&TEST_DATA, "gujarati/Samyak-Gujarati.ttf");
        }

        #[test]
        fn test_rekha() {
            run_test_bad(&TEST_DATA, "gujarati/Rekha.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansGujarati-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifGujarati-Regular.ttf");
        }
    }

    mod oriya {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.or",
            script_tag: "orya",
            lang_tag: "ORI",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "oriya/lohit_or.ttf");
        }

        #[test]
        fn test_ori1uni() {
            run_test_bad(&TEST_DATA, "oriya/utkalm.ttf");
        }

        #[test]
        fn test_kalinga() {
            run_test_bad(&TEST_DATA, "oriya/kalinga.ttf");
        }

        #[test]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansOriya-Regular.ttf");
        }
    }

    mod tamil {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.ta",
            script_tag: "taml",
            lang_tag: "TAM",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "tamil/lohit_ta.ttf");
        }

        #[test]
        fn test_tamu() {
            run_test_bad(&TEST_DATA, "tamil/TAMu_Kalyani.ttf");
        }

        #[test]
        fn test_latha() {
            run_test_bad(&TEST_DATA, "tamil/latha.ttf");
        }

        #[test]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansTamil-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifTamil-Regular.ttf");
        }
    }

    mod telugu {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.te",
            script_tag: "telu",
            lang_tag: "TEL",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "telugu/lohit_te.ttf");
        }

        #[test]
        fn test_gautami() {
            run_test_bad(&TEST_DATA, "telugu/gautami.ttf");
        }

        #[test]
        fn test_mandali() {
            run_test_bad(&TEST_DATA, "telugu/Mandali-Regular.ttf");
        }

        #[test]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansTelugu-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifTelugu-Regular.ttf");
        }
    }

    mod kannada {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.kn",
            script_tag: "knda",
            lang_tag: "KAN",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "kannada/lohit_kn.ttf");
        }

        #[test]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansKannada-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifKannada-Regular.ttf");
        }

        #[test]
        fn test_tunga() {
            run_test_bad(&TEST_DATA, "kannada/tunga.ttf");
        }
    }

    mod malayalam {
        use super::*;

        const TEST_DATA: TestData = TestData {
            inputs_path: "bad/bad.ml",
            script_tag: "mlym",
            lang_tag: "MAL",
        };

        #[test]
        fn test_lohit() {
            run_test_bad(&TEST_DATA, "malayalam/lohit_ml.ttf");
        }

        #[test]
        fn test_rachana_indic1() {
            run_test_bad(&TEST_DATA, "malayalam/Rachana_w01.ttf");
        }

        #[test]
        fn test_chilanka() {
            run_test_bad(&TEST_DATA, "malayalam/Chilanka-Regular.ttf");
        }

        #[test]
        fn test_dyuthi() {
            run_test_bad(&TEST_DATA, "malayalam/Dyuthi-Regular.ttf");
        }

        #[test]
        fn test_nirmala() {
            run_test_bad(&TEST_DATA, "indic/Nirmala.ttf");
        }

        #[test]
        fn test_noto_sans() {
            run_test_bad(&TEST_DATA, "noto/NotoSansMalayalam-Regular.ttf");
        }

        #[test]
        fn test_noto_serif() {
            run_test_bad(&TEST_DATA, "noto/NotoSerifMalayalam-Regular.ttf");
        }

        #[test]
        fn test_rachana_indic2() {
            run_test_bad(&TEST_DATA, "malayalam/Rachana-Regular.ttf");
        }
    }
}
